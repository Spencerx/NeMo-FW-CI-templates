# Copyright (c) 2020-2021, NVIDIA CORPORATION.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
name: Build docs
on:
  workflow_call:
    inputs:
      docs-directory:
        description: "Directory where the docs will be built"
        required: false
        type: string
        default: "docs"
      requirements-file:
        description: "Requirements file for building the docs"
        required: false
        type: string
        default: ""
      fail-on-warning:
        description: "Whether to fail the build on Sphinx warnings"
        required: false
        type: boolean
        default: true
      sync-all:
        description: "Whether to sync all dependencies or just the docs group"
        required: false
        type: boolean
        default: false
      ref:
        description: Ref (SHA or branch name) to build the docs for
        required: false
        type: string
        default: ${{ github.sha }}

jobs:
  main:
    name: Build docs
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: "recursive"
          ref: ${{ inputs.ref }}
          fetch-depth: 0

      - name: Install uv
        uses: astral-sh/setup-uv@v5

      - name: Install dependencies
        run: |
          uv venv
          if [ "${{ inputs.sync-all }}" = "true" ]; then
            uv sync --all-extras --all-groups
          elif [ -f "${{ inputs.requirements-file }}" ]; then
            uv pip install -r ${{ inputs.requirements-file }}
          else
            uv sync --only-group docs
          fi

      - name: Sphinx build
        run: |
          source .venv/bin/activate
          cd ${{ inputs.docs-directory }}

          if [ "${{ inputs.fail-on-warning }}" = "true" ]; then
            echo "Building docs with --fail-on-warning"
            sphinx-build --fail-on-warning --builder html . _build/html
          else
            echo "Building docs without --fail-on-warning"
            sphinx-build --builder html . _build/html
          fi

      - name: Upload docs as artifact
        uses: actions/upload-artifact@v4
        with:
          name: docs-html
          path: ${{ inputs.docs-directory }}/_build/html
          retention-days: 7

      - name: Sphinx linkcheck
        run: |
          source .venv/bin/activate
          cd ${{ inputs.docs-directory }}
          sphinx-build --builder linkcheck . _build/linkcheck || true

      - name: Upload linkcheck output
        uses: actions/upload-artifact@v4
        with:
          name: linkcheck-artifact
          path: ${{ inputs.docs-directory }}/_build/linkcheck
          retention-days: 7

      - name: Check for unknown broken links
        run: |
          FALSE_POSITIVES_JSON=${{ inputs.docs-directory }}/broken_links_false_positives.json
          NEEDS_REVIEW_JSON=${{ inputs.docs-directory }}/broken_links_needing_review.json
          LINKCHECK_JSON=${{ inputs.docs-directory }}/_build/linkcheck/output.json

          function check_environment {
            local err=0
            if ! [ -x "$(command -v jq)" ]; then
              echo "jq is required but is not found."
              err=$((err + 1))
            fi
            if [ ! -f "${LINKCHECK_JSON}" ]; then
              echo "Did not find linkcheck output JSON file: ${LINKCHECK_JSON}."
              err=$((err + 1))
            fi
            if [ "${err}" -gt 0 ]; then
              exit 2
            fi
          }

          function check_links {
            local err=0
            broken=$(jq -s 'map(select(.status=="broken"))' "$LINKCHECK_JSON")
            count=$(echo "${broken}" | jq 'length')
            for i in $(seq 0 $(($count - 1)))
            do
              entry=$(echo "${broken}" | jq ".[${i}]")
              link=$(echo "${entry}" | jq -r '.uri')
              local false_positive_resp="false"
              local needs_review_resp="false"
              if [ -f "${FALSE_POSITIVES_JSON}" ]; then
                false_positive_resp=$(jq --arg check "${link}" -s 'any(.uri == $check)' < "${FALSE_POSITIVES_JSON}")
              fi
              if [ -f "${NEEDS_REVIEW_JSON}" ]; then
                needs_review_resp=$(jq --arg check "${link}" -s 'any(.uri == $check)' < "${NEEDS_REVIEW_JSON}")
              fi

              # "false" indicates that the URL did not match any of the URIs in the false positive file.
              if [[ "false" = "${false_positive_resp}" && "false" = "${needs_review_resp}" ]]; then
                err=$((err + 1))
                echo $entry
              fi
            done

            if [ "${err}" -gt 0 ]; then
              echo "Found ${err} broken links that are not in exclusion lists"
              exit 1
            fi
          }

          check_environment
          check_links
